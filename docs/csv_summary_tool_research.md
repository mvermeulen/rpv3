# Research: CSV Summary Tool for RPV3

## Objective
Create a tool to summarize the CSV output generated by the RPV3 kernel tracer.
**Requirements:**
1.  Input: RPV3 CSV trace file.
2.  Processing:
    *   Group by unique `KernelName`.
    *   Count number of calls per kernel.
    *   Sum total elapsed time (Duration) per kernel.
3.  Output: Display results sorted by total time in descending order.

## Input Format Analysis
The RPV3 CSV format is:
```csv
KernelName,ThreadID,CorrelationID,...,DurationNs,DurationUs,...
```
*   **KernelName**: First column. **Crucial Note**: C++ kernel names can contain commas (e.g., `foo<int, float>`). These are enclosed in double quotes (e.g., `"foo<int, float>"`).
*   **Duration**: Available as `DurationNs` (nanoseconds, integer) and `DurationUs` (microseconds, float). Using `DurationNs` avoids floating point precision issues during summation.

## Proposed Alternatives

### Option 1: Python Script (Recommended)
A standalone Python script using the standard `csv` library.

*   **Implementation**: `utils/summarize_trace.py`
*   **Pros**:
    *   **Robust Parsing**: The standard `csv` module correctly handles quoted fields with commas, which is essential for C++ kernel names.
    *   **Ease of Development**: Dictionary-based aggregation and sorting is trivial in Python.
    *   **Formatting**: Easy to print pretty tables (e.g., using f-strings or `tabulate`).
    *   **Extensibility**: Easy to add plotting or more complex stats (min/max/std dev) later.
*   **Cons**:
    *   Requires Python 3 runtime (standard on most Linux systems).

**Prototype Snippet**:
```python
import csv
import sys
from collections import defaultdict

stats = defaultdict(lambda: {'count': 0, 'total_ns': 0})

with open(sys.argv[1], newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        name = row['KernelName']
        stats[name]['count'] += 1
        stats[name]['total_ns'] += int(row['DurationNs'])

# Sort and print...
```

### Option 2: C++ Utility
A compiled C++ tool included in the `utils/` directory.

*   **Implementation**: `utils/summarize_trace.cpp`
*   **Pros**:
    *   **Performance**: Extremely fast, suitable for massive trace files (GBs).
    *   **No Dependencies**: Compiles into a standalone binary.
    *   **Consistency**: Matches the primary language of the project.
*   **Cons**:
    *   **Complexity**: Requires writing a CSV parser that handles quoted strings (or pulling in a single-header library). `std::getline` with delimiter ',' is **insufficient** due to commas in kernel names.
    *   **Build System**: Needs to be added to `CMakeLists.txt` and `Makefile`.

### Option 3: Shell Script (awk/sed)
A shell script using `awk`.

*   **Implementation**: `utils/summarize_trace.sh`
*   **Pros**:
    *   **Portability**: Runs on any minimal Linux install.
*   **Cons**:
    *   **Parsing Difficulty**: Standard `awk -F,` **fails** on quoted strings containing commas.
    *   **Workaround**: Would require complex `FPAT` (GNU awk only) or `sed` pre-processing to hide commas inside quotes. This makes the script fragile and hard to maintain.
    *   **Recommendation**: **Not recommended** due to the C++ kernel name requirement.

## Recommendation

**Proceed with Option 1 (Python Script).**

**Reasoning**:
1.  **Correctness**: It reliably handles the specific edge case of commas in quoted C++ kernel names without complex logic.
2.  **Maintainability**: The code will be concise (~50 lines) and easy to read.
3.  **Availability**: Python is ubiquitous in HPC and dev environments where RPV3 is used.

If a binary-only solution is strictly required, **Option 2 (C++)** is the fallback, but it requires implementing a state-machine CSV parser.
